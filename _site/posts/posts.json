[
  {
    "path": "posts/2020-12-25-elevation-maps-in-r/",
    "title": "Elevation Maps in R",
    "description": "Learn to create 3D and ridgeline plots with an animation bonus.",
    "author": [
      {
        "name": "Umair Durrani",
        "url": {}
      }
    ],
    "date": "2020-12-25",
    "categories": [],
    "contents": "\r\nIn this post I show you how to create aesthetically pleasant and useful maps in R using ground elevation data.\r\nGetting the Elevation Data in R\r\nI got the elevation data from Geohub which provides the data for Ontario, Canada in the .tif format. The .tif file type can be easily imported in R using the raster package. If you want to use United States data, the elevatr R package can help with that.\r\nI have downloaded 2 files for Ontario, one each for north and south Ontario, and then unzipped them. Let’s start by loading the libraries and importing the data.\r\n\r\n\r\n# Load Libraries ----------------------------------------------------------\r\n\r\nsuppressPackageStartupMessages( library(raster) )\r\nsuppressPackageStartupMessages( library(tidyverse) )\r\nsuppressPackageStartupMessages( library(ggridges) )\r\nsuppressPackageStartupMessages( library(rayshader) )\r\nsuppressPackageStartupMessages( library(gganimate) )\r\nsuppressPackageStartupMessages( library(sf) )\r\n\r\n\r\n\r\n\r\n# Load Data ---------------------------------------------------------------\r\nont_s <- raster(here::here(\"PDEM_South.tif\"))\r\nont_n <- raster(here::here(\"PDEM_North.tif\"))\r\n\r\n\r\n\r\nNote that I used here::here() to get my file paths. Let’s see what’s in these 2 files:\r\n\r\n\r\nont_s\r\n\r\n\r\nclass      : RasterLayer \r\ndimensions : 32001, 55685, 1781975685  (nrow, ncol, ncell)\r\nresolution : 30, 30  (x, y)\r\nextent     : 151020, 1821570, 11620380, 12580410  (xmin, xmax, ymin, ymax)\r\ncrs        : +proj=lcc +lat_0=0 +lon_0=-85 +lat_1=44.5 +lat_2=53.5 +x_0=930000 +y_0=6430000 +datum=NAD83 +units=m +no_defs \r\nsource     : E:/OneDrive - University of Windsor/udurrani_distill/PDEM_South.tif \r\nnames      : PDEM_South \r\nvalues     : 40.00449, 669.0026  (min, max)\r\n\r\nont_n\r\n\r\n\r\nclass      : RasterLayer \r\ndimensions : 29768, 42540, 1266330720  (nrow, ncol, ncell)\r\nresolution : 30, 30  (x, y)\r\nextent     : 160260, 1436460, 12487470, 13380510  (xmin, xmax, ymin, ymax)\r\ncrs        : +proj=lcc +lat_0=0 +lon_0=-85 +lat_1=44.5 +lat_2=53.5 +x_0=930000 +y_0=6430000 +datum=NAD83 +units=m +no_defs \r\nsource     : E:/OneDrive - University of Windsor/udurrani_distill/PDEM_North.tif \r\nnames      : PDEM_North \r\nvalues     : -2.472506, 520.3692  (min, max)\r\n\r\nThey are clearly raster file types. You can see in the dimensions section that the number of cells (i.e. number of data points) is quite a large number for both layers. This means that if we try to plot these data with a typical RAM size, say 8GB, we’d have a bad time1. So, to create maps we’d need to decrease the size of these raster layers.\r\nBefore going to the next step, an important thing to note here is that the crs section above indicates that the units of the x, y and elevation coordinates are meters. The elevation is stored here under the names PDEM_South and PDEM_North in the two raster layers.\r\nSlimming Down the Raster Data\r\nThe sampleRegular function from the raster package lets you take a sample of the original raster data by specifying the size argument. I experimented with different sizes, and was satisfied with size=50000, as it provided a good visual quality in the maps. The last argument here is asRaster that returns a raster data when TRUE.\r\nOnce we get a reduced raster data, we use the rayshader::raster_to_matrix() function to put all the elevation values in a 2D matrix where the 2 dimensions are x and y coordinates. Following shows the results (only the first 5 rows and columns for each layer):\r\n\r\n\r\nont_s_m <- ont_s %>% \r\n  raster::sampleRegular(ont_s, size=50000, asRaster=TRUE) %>%\r\n  rayshader::raster_to_matrix()\r\n\r\nont_s_m[1:5, 1:5]\r\n\r\n\r\n     [,1] [,2]     [,3]     [,4]     [,5]\r\n[1,]   NA   NA       NA 349.9258 337.7366\r\n[2,]   NA   NA 340.8874 345.7653 342.1966\r\n[3,]   NA   NA 350.0495 349.4100 345.2380\r\n[4,]   NA   NA 357.0622 351.3358 331.3604\r\n[5,]   NA   NA 359.2308 363.4488 333.8035\r\n\r\nont_n_m <- ont_n %>% \r\n  raster::sampleRegular(ont_n, size=50000, asRaster=TRUE) %>%\r\n  rayshader::raster_to_matrix()\r\n\r\nont_n_m[1:5, 1:5]\r\n\r\n\r\n     [,1] [,2] [,3] [,4] [,5]\r\n[1,]   NA   NA   NA   NA   NA\r\n[2,]   NA   NA   NA   NA   NA\r\n[3,]   NA   NA   NA   NA   NA\r\n[4,]   NA   NA   NA   NA   NA\r\n[5,]   NA   NA   NA   NA   NA\r\n\r\n3D Raster Maps with Rayshader\r\nWe use the awesome rayshader package here to plot the raster map in 3D.\r\n\r\n\r\nont_n_m %>%\r\n  sphere_shade(texture = \"imhof1\") %>%\r\n  add_shadow(ray_shade(ont_n_m, zscale = 30), 0.5) %>%\r\n  add_shadow(ambient_shade(ont_n_m), 0) %>%\r\n  plot_3d(ont_n_m, zscale = 10, fov = 0, \r\n          theta = 0, zoom = 0.75, phi = 70, \r\n          windowsize = c(1000, 800),\r\n          solid=FALSE)\r\nSys.sleep(0.3)\r\nrender_snapshot(clear=T, title_text = \"Ontario (North)\")\r\n\r\n\r\n\r\nrgl::rgl.close()\r\n\r\n\r\n\r\n\r\nCreating Ridgeline Maps\r\nRaster maps are beautiful but take long time to render. Another technique that can show the elevation data very effectively is a ridgeline plot. I was previously familiar with the ggridges package but was recently reminded of it when I saw the ridgeline plots app made by Andrei Kashcha. So, I decided to use elevation height in the ggridges::geom_ridgeline() function.\r\nBut a ridgeline plot uses 3 arguments, x, y, and height. So, to proceed, we need to extract these coordinates from the raster files. Again, we use the raster::sampleRegular function for slimming the data, but also use the xy=TRUE option to get the three coordinates:\r\n\r\n\r\n## Sample 10000 values\r\ndf_s <- data.frame(sampleRegular(ont_s, 10000, xy=TRUE))\r\ndf_n <- data.frame(sampleRegular(ont_n, 10000, xy=TRUE))\r\n\r\n\r\n## Rename to 'elevation'\r\ndf_s <- df_s %>% \r\n  rename(elevation = PDEM_South)\r\n\r\ndf_n <- df_n %>% \r\n  rename(elevation = PDEM_North)\r\n\r\n\r\n## Combine the two\r\ndf <- bind_rows(df_s, df_n)\r\n\r\nhead(df)\r\n\r\n\r\n       x        y elevation\r\n1 157395 12574035        NA\r\n2 170145 12574035        NA\r\n3 182895 12574035        NA\r\n4 195645 12574035        NA\r\n5 208395 12574035        NA\r\n6 221145 12574035        NA\r\n\r\nNote that elevation above is not completely NA (you are seeing the first 6 rows only).\r\n\r\nMy attempts to use ggridges::geom_ridgeline() were not successful. Instead, the other function, ggridges::geom_density_ridges is what can effectively generate the nice elevation lines for creating the 3D effect that Andrei showed. I learnt this from Travis M. White’s blogpost. I also found great tips for theming the map.\r\n\r\nPlots\r\nThe data is ready now, back to making the maps. A first try:\r\n\r\n\r\nggplot() +\r\n  geom_density_ridges(data = df,\r\n                      aes(x, y, \r\n                          group=y,\r\n                          height = elevation),\r\n                      stat = \"identity\",\r\n                      scale=20) +\r\n  theme_void() \r\n\r\n\r\n\r\n\r\nSee the 3D effect?\r\nThe scale argument controls the overlap between the ridgelines. I experimented with different values and settled with 20.\r\nNow with a dark theme:\r\n\r\n\r\nggplot() +\r\n  geom_density_ridges(data = df,\r\n                      aes(x, y, \r\n                          group=y,\r\n                          height = elevation),\r\n                      stat = \"identity\",\r\n                      scale=20,\r\n                      fill=\"black\",\r\n                      color=\"white\") +\r\n  scale_x_continuous(name = \"Ontario\") +\r\n  theme_void() +\r\n  theme(\r\n             panel.background = element_rect(fill = \"black\"),\r\n            \r\n             plot.background = element_rect(fill = \"black\"),\r\n           \r\n             axis.title.x = element_text(colour = 'white', \r\n                                         size = 18))\r\n\r\n\r\n\r\n\r\nFor some reason, this reminded me of neon signs. So, I got an idea!\r\nAnimating the Ridgeline Map\r\nLet’s animate the map with colors. For doing so, I create 2 more copies of the data df and then give one color to each (there may be a better way to do this). Then I use transition_reveal to color the lines turn by turn:\r\n\r\n\r\ncolos = rep(c(\"red\", \"yellow\", \"green\"), each = nrow(df))\r\n\r\nretro <- bind_rows(df, df, df) %>% \r\n  mutate(colorz = colos)\r\n\r\nani1 <- ggplot(data = retro ,\r\n       aes(x, y, \r\n           group=y,\r\n           height = elevation))+\r\n  geom_density_ridges(stat = \"identity\",\r\n                      scale=20,\r\n                      fill=\"black\",\r\n                      aes(color=colorz)) +\r\n  scale_x_continuous(name = \"Ontario\") +\r\n  theme_void() +\r\n  theme(\r\n    legend.position = \"none\",\r\n    panel.background = element_rect(fill = \"black\"),\r\n    \r\n    plot.background = element_rect(fill = \"black\"),\r\n    \r\n    axis.title.x = element_text(colour = 'white', \r\n                                size = 18)) +\r\n    transition_states(colorz,\r\n                    transition_length = 2,\r\n                    state_length = 1)\r\n\r\nani1\r\n\r\n\r\n\r\n\r\nOf course, we can also animate by x or y dimensions:\r\n\r\n\r\nani2 <- ggplot(data = df,\r\n       aes(x, y, \r\n           group=y,\r\n           height = elevation))+\r\n  geom_density_ridges(stat = \"identity\",\r\n                      scale=8,\r\n                      fill=\"black\",\r\n                      color = \"white\") +\r\n  scale_x_continuous(name = \"Ontario\") +\r\n  theme_void() +\r\n  theme(\r\n    legend.position = \"none\",\r\n    panel.background = element_rect(fill = \"black\"),\r\n    \r\n    plot.background = element_rect(fill = \"black\"),\r\n    \r\n    axis.title.x = element_text(colour = 'white', \r\n                                size = 18)) + \r\n  transition_manual(x, cumulative = T) + \r\n  ease_aes('linear')\r\n\r\n\r\nani2\r\n\r\n\r\n\r\n\r\nThis ends the blogpost. I hope you’d find something useful here for your mapping needs.\r\n\r\nRead the discussion here: https://stackoverflow.com/questions/61535383/r-runs-out-of-memory-plotting-data-frame-with-ggplot2↩︎\r\n",
    "preview": "posts/2020-12-25-elevation-maps-in-r/ontario_map.gif",
    "last_modified": "2020-12-25T04:16:16-05:00",
    "input_file": {}
  },
  {
    "path": "posts/2020-12-19-hellowww/",
    "title": "Hello World",
    "description": "First post",
    "author": [
      {
        "name": "Umair Durrani",
        "url": {}
      }
    ],
    "date": "2020-12-19",
    "categories": [],
    "contents": "\r\nThis is my first post on this new website, created with the distill package in R.\r\n\r\n\r\n\r\n\r\n",
    "preview": "https://media.giphy.com/media/MeJgB3yMMwIaHmKD4z/giphy.gif",
    "last_modified": "2020-12-19T02:04:33-05:00",
    "input_file": {}
  }
]
